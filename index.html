<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dontlookdown3d</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e0f2fe; font-family: 'Segoe UI', Tahoma, sans-serif; user-select: none; }
        canvas { display: block; }

        /* Crosshair for 1st person aiming */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: rgba(255, 255, 255, 0.8); border: 1px solid rgba(0,0,0,0.5);
            transform: translate(-50%, -50%); border-radius: 50%; pointer-events: none;
        }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        #top-hud { padding: 20px 40px; display: flex; justify-content: space-between; background: linear-gradient(to bottom, rgba(0,0,0,0.4), transparent); }
        .hud-text { font-size: 2rem; font-weight: bold; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        #altitude { color: #38bdf8; }

        #controls { text-align: center; color: rgba(255,255,255,0.9); padding-bottom: 20px; font-size: 1.1rem; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        .key { display: inline-block; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; border: 1px solid #555; margin: 0 2px; }

        #death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.9); display: none; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto; z-index: 10;
        }
        #death-screen h1 { font-size: 5rem; color: #ef4444; margin-bottom: 0; text-transform: uppercase; letter-spacing: 5px; }
        #death-score { font-size: 2rem; color: white; margin: 20px 0 40px 0; }
        button { background: #38bdf8; color: #0f172a; border: none; padding: 15px 40px; font-size: 1.5rem; font-weight: bold; border-radius: 8px; cursor: pointer; text-transform: uppercase; transition: 0.2s; }
        button:hover { transform: scale(1.05); background: #7dd3fc; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="crosshair"></div>

    <div id="ui-layer">
        <div id="top-hud">
            <div class="hud-text" id="altitude">0m</div>
        </div>
        
        <div id="controls">
            Move: <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> &nbsp;|&nbsp; 
            Look: <span class="key">Arrows</span> &nbsp;|&nbsp; 
            Jump: <span class="key">Space</span>
        </div>
    </div>

    <div id="death-screen">
        <h1>YOU FELL</h1>
        <div id="death-score">Height Reached: 0m</div>
        <button onclick="restartGame()">Try Again</button>
    </div>

    <script>
        // --- 1. SETUP THREE.JS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xbae6fd);
        scene.fog = new THREE.Fog(0xbae6fd, 10, 80);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
        // Important: YXZ order prevents the camera from rolling/tilting sideways when looking around
        camera.rotation.order = 'YXZ'; 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(10, 30, 20);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 2. MATERIALS & GROUND ---
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x22c55e, roughness: 0.8 });
        const staticPlatMat = new THREE.MeshStandardMaterial({ color: 0x64748b, roughness: 0.6 });
        const movingPlatMat = new THREE.MeshStandardMaterial({ color: 0xf97316, roughness: 0.4 }); // Orange for moving

        const ground = new THREE.Mesh(new THREE.BoxGeometry(100, 2, 100), groundMat);
        ground.position.set(0, -1, 0);
        ground.receiveShadow = true;
        scene.add(ground);

        // --- 3. LEVEL GENERATOR ---
        let platforms = [];
        let highestY = 0;

        function createPlatform(x, y, z, isMoving) {
            const w = Math.random() * 2 + 4; // Width: 4 to 6
            const d = Math.random() * 2 + 4; // Depth: 4 to 6
            const mat = isMoving ? movingPlatMat : staticPlatMat;
            
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, 1, d), mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true; mesh.receiveShadow = true;
            scene.add(mesh);

            platforms.push({ 
                mesh, x, y, z, w, d, 
                isMoving, 
                startX: x, startZ: z,
                timeOffset: Math.random() * 100,
                moveAxis: Math.random() > 0.5 ? 'x' : 'z',
                dx: 0, dz: 0 // Track velocity for carrying player
            });

            if (y > highestY) highestY = y;
        }

        function generateLevel() {
            platforms.forEach(p => scene.remove(p.mesh));
            platforms = [];
            highestY = 0;

            // Start pad
            createPlatform(0, 2, 0, false);

            let px = 0; let py = 2; let pz = 0;
            for(let i = 0; i < 30; i++) {
                // Spread platforms out: Up to 8 units away horizontally, 2 to 4 units up
                let angle = Math.random() * Math.PI * 2;
                let dist = Math.random() * 4 + 5; // 5 to 9 units apart
                
                px += Math.cos(angle) * dist;
                pz += Math.sin(angle) * dist;
                py += Math.random() * 2 + 2.5; // Climb 2.5 to 4.5 units

                let isMoving = Math.random() > 0.6; // 40% chance to be a moving platform
                createPlatform(px, py, pz, isMoving);
            }
        }

        // --- 4. PLAYER & INPUT ---
        const player = {
            x: 0, y: 5, z: 0, // y is eye-level
            vx: 0, vy: 0, vz: 0,
            yaw: 0, pitch: 0,
            radius: 0.6, height: 2.0, // Used for collisions
            onGround: false, isDead: false, maxAltitude: 0,
            currentPlatform: null
        };

        const keys = { w: false, a: false, s: false, d: false, space: false, up: false, down: false, left: false, right: false };
        
        window.addEventListener('keydown', (e) => {
            if (player.isDead) return;
            const k = e.key.toLowerCase();
            if (k === 'w') keys.w = true; if (k === 'a') keys.a = true;
            if (k === 's') keys.s = true; if (k === 'd') keys.d = true;
            if (k === ' ') { keys.space = true; e.preventDefault(); }
            if (e.key === 'ArrowUp') { keys.up = true; e.preventDefault(); }
            if (e.key === 'ArrowDown') { keys.down = true; e.preventDefault(); }
            if (e.key === 'ArrowLeft') { keys.left = true; e.preventDefault(); }
            if (e.key === 'ArrowRight') { keys.right = true; e.preventDefault(); }
        });

        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'w') keys.w = false; if (k === 'a') keys.a = false;
            if (k === 's') keys.s = false; if (k === 'd') keys.d = false;
            if (k === ' ') keys.space = false;
            if (e.key === 'ArrowUp') keys.up = false;
            if (e.key === 'ArrowDown') keys.down = false;
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
        });

        // --- AABB COLLISION ---
        function checkCollision(px, py, pz) {
            let feetY = py - player.height; // Feet are below eye level
            
            // Check Ground First
            if (feetY <= 0 && px > -50 && px < 50 && pz > -50 && pz < 50) {
                return { isGround: true, y: 0 };
            }

            for (let p of platforms) {
                let pMinX = p.x - p.w/2 - player.radius;
                let pMaxX = p.x + p.w/2 + player.radius;
                let pMinZ = p.z - p.d/2 - player.radius;
                let pMaxZ = p.z + p.d/2 + player.radius;
                let pTop = p.y + 0.5;
                let pBottom = p.y - 0.5;

                // If player is within X/Z bounds and their feet intersect the top of the platform
                if (px > pMinX && px < pMaxX && pz > pMinZ && pz < pMaxZ) {
                    if (feetY <= pTop && py >= pBottom) {
                        return p;
                    }
                }
            }
            return null;
        }

        // --- 5. MAIN LOOP ---
        const clock = new THREE.Clock();

        function update() {
            if (player.isDead) return;
            const dt = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            // -- Animate Moving Platforms --
            for (let p of platforms) {
                if (p.isMoving) {
                    let oldX = p.x; let oldZ = p.z;
                    
                    // Oscillate back and forth using Sine wave
                    let moveAmount = Math.sin(time * 2 + p.timeOffset) * 6; // Move 6 units 
                    
                    if (p.moveAxis === 'x') p.x = p.startX + moveAmount;
                    else p.z = p.startZ + moveAmount;

                    // Calculate how far it moved this frame
                    p.dx = p.x - oldX;
                    p.dz = p.z - oldZ;
                    
                    p.mesh.position.set(p.x, p.y, p.z);
                }
            }

            // -- Camera Look (Arrows) --
            let lookSpeed = 2.5 * dt;
            if (keys.left) player.yaw += lookSpeed;
            if (keys.right) player.yaw -= lookSpeed;
            if (keys.up) player.pitch += lookSpeed;
            if (keys.down) player.pitch -= lookSpeed;
            // Lock looking straight up/down so you don't flip backwards
            player.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, player.pitch));

            // -- Player WASD Movement --
            let moveSpeed = 10;
            let dirX = 0; let dirZ = 0;
            if (keys.w) dirZ = -1; if (keys.s) dirZ = 1;
            if (keys.a) dirX = -1; if (keys.d) dirX = 1;

            if (dirX !== 0 || dirZ !== 0) {
                // Normalize diagonal movement
                let length = Math.sqrt(dirX*dirX + dirZ*dirZ);
                dirX /= length; dirZ /= length;
                
                // Rotate movement to match where the camera is looking
                let s = Math.sin(player.yaw); let c = Math.cos(player.yaw);
                player.vx = (dirX * c + dirZ * s) * moveSpeed;
                player.vz = (-dirX * s + dirZ * c) * moveSpeed;
            } else {
                player.vx *= 0.7; // Friction
                player.vz *= 0.7;
            }

            // Apply Horizontal Movement
            player.x += player.vx * dt;
            player.z += player.vz * dt;

            // -- Vertical Physics & Collisions --
            player.vy -= 30 * dt; // Gravity
            player.y += player.vy * dt;
            player.onGround = false;
            player.currentPlatform = null;

            let hit = checkCollision(player.x, player.y, player.z);
            if (hit) {
                if (player.vy < 0) {
                    // Snap feet to top of platform/ground
                    player.y = (hit.isGround ? hit.y : hit.y + 0.5) + player.height;
                    player.vy = 0;
                    player.onGround = true;
                    player.currentPlatform = hit;
                }
            }

            // -- CARRY PLAYER ON MOVING PLATFORM --
            if (player.onGround && player.currentPlatform && player.currentPlatform.isMoving) {
                player.x += player.currentPlatform.dx;
                player.z += player.currentPlatform.dz;
            }

            // Jump
            if (player.onGround && keys.space) {
                player.vy = 14;
                player.onGround = false;
            }

            // Apply to Camera
            camera.rotation.set(player.pitch, player.yaw, 0);
            camera.position.set(player.x, player.y, player.z);

            // -- Endless Generation --
            if (highestY - player.y < 40) {
                let lastP = platforms[platforms.length - 1];
                let angle = Math.random() * Math.PI * 2;
                let dist = Math.random() * 4 + 5;
                let nx = lastP.x + Math.cos(angle) * dist;
                let ny = lastP.y + Math.random() * 2 + 2.5;
                let nz = lastP.z + Math.sin(angle) * dist;
                createPlatform(nx, ny, nz, Math.random() > 0.6);
            }

            // UI and Death
            let currentAlt = Math.max(0, Math.floor(player.y - player.height));
            if (currentAlt > player.maxAltitude) player.maxAltitude = currentAlt;
            document.getElementById('altitude').innerText = currentAlt + "m";

            // Die if you fall more than 20 meters below your max altitude
            if (player.y < player.maxAltitude - 20 && player.maxAltitude > 5) {
                player.isDead = true;
                document.getElementById('death-score').innerText = `Height Reached: ${player.maxAltitude}m`;
                document.getElementById('death-screen').style.display = 'flex';
            }

            renderer.render(scene, camera);
        }

        function restartGame() {
            document.getElementById('death-screen').style.display = 'none';
            player.isDead = false;
            player.x = 0; player.y = 5; player.z = 0;
            player.vx = 0; player.vy = 0; player.vz = 0;
            player.yaw = 0; player.pitch = 0;
            player.maxAltitude = 0;
            generateLevel();
        }

        generateLevel();
        renderer.setAnimationLoop(update);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
