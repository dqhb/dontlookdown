<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dontlookdown</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, sans-serif; user-select: none; }
        canvas { display: block; }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        #top-hud { padding: 20px 40px; display: flex; justify-content: space-between; background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent); }
        .hud-text { font-size: 2rem; font-weight: bold; color: white; text-shadow: 0 4px 6px rgba(0,0,0,0.5); }
        #altitude { color: #38bdf8; }
        #high-score { color: #fbbf24; font-size: 1.2rem; margin-top: 5px; }

        #controls { text-align: center; color: rgba(255,255,255,0.8); padding-bottom: 20px; font-size: 1.1rem; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        .key { display: inline-block; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; border: 1px solid #555; margin: 0 2px; }

        #death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.9); display: none; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto; z-index: 10;
        }
        #death-screen h1 { font-size: 5rem; color: #ef4444; margin-bottom: 0; text-transform: uppercase; letter-spacing: 5px; }
        #death-score { font-size: 2rem; color: white; margin: 20px 0 40px 0; }
        button { background: #38bdf8; color: #0f172a; border: none; padding: 15px 40px; font-size: 1.5rem; font-weight: bold; border-radius: 8px; cursor: pointer; text-transform: uppercase; transition: 0.2s; }
        button:hover { transform: scale(1.05); background: #7dd3fc; box-shadow: 0 0 20px #38bdf8; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="top-hud">
            <div>
                <div class="hud-text" id="altitude">0m</div>
                <div id="high-score">Best: 0m</div>
            </div>
        </div>
        
        <div id="controls">
            Move: <span class="key">W</span><span class="key">S</span> &nbsp;|&nbsp; 
            Turn: <span class="key">A</span><span class="key">D</span> &nbsp;|&nbsp; 
            Camera: <span class="key">Arrows</span> &nbsp;|&nbsp; 
            Jump: <span class="key">Space</span>
        </div>
    </div>

    <div id="death-screen">
        <h1>YOU FELL</h1>
        <div id="death-score">Final Altitude: 0m</div>
        <button onclick="restartGame()">Try Again</button>
    </div>

    <script>
        // --- 1. SETUP THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 2. GENERATE PROCEDURAL TEXTURES ---
        function createCheckerboard() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#1e293b'; 
            context.fillRect(0, 0, 256, 256);
            
            context.fillStyle = '#334155';
            context.fillRect(0, 0, 128, 128);
            context.fillRect(128, 128, 128, 128);
            
            context.strokeStyle = '#38bdf8';
            context.lineWidth = 4;
            context.strokeRect(2, 2, 252, 252);

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        const platformMaterial = new THREE.MeshStandardMaterial({ 
            map: createCheckerboard(), 
            roughness: 0.7, metalness: 0.2 
        });

        // --- 3. PLATFORM GENERATOR ---
        let platforms = [];
        let highestPlatformY = 0;
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);

        function createPlatform(x, y, z, width, depth) {
            const mesh = new THREE.Mesh(boxGeo, platformMaterial);
            mesh.scale.set(width, 1, depth);
            mesh.position.set(x, y, z);
            mesh.castShadow = true; mesh.receiveShadow = true;
            
            const clonedMat = platformMaterial.clone();
            clonedMat.map = platformMaterial.map.clone();
            clonedMat.map.repeat.set(width / 4, depth / 4);
            clonedMat.map.wrapS = THREE.RepeatWrapping;
            clonedMat.map.wrapT = THREE.RepeatWrapping;
            mesh.material = clonedMat;

            scene.add(mesh);
            platforms.push({ mesh, x, y, z, w: width, d: depth });
            if (y > highestPlatformY) highestPlatformY = y;
        }

        function generateInitialWorld() {
            platforms.forEach(p => scene.remove(p.mesh));
            platforms = [];
            highestPlatformY = 0;

            createPlatform(0, -1, 0, 15, 15); // Start pad

            let px = 0; let py = 2; let pz = 0;
            for(let i=0; i<20; i++) {
                px += (Math.random() - 0.5) * 12;
                py += Math.random() * 2 + 1;
                pz += (Math.random() - 0.5) * 12;
                let size = Math.random() * 4 + 3;
                createPlatform(px, py, pz, size, size);
            }
        }

        // --- 4. PLAYER & PHYSICS ---
        const player = {
            x: 0, y: 5, z: 0, 
            vx: 0, vy: 0, vz: 0,
            facing: 0, // Player rotation (yaw)
            camYaw: 0, pitch: 0.3, // Camera rotation
            onGround: false, isDead: false, maxAltitude: 0
        };

        // Multi-part Player Mesh
        const playerGroup = new THREE.Group();
        
        // Metallic Body
        const bodyMat = new THREE.MeshStandardMaterial({color: 0x475569, roughness: 0.3, metalness: 0.7});
        const bodyMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 2, 16), bodyMat);
        bodyMesh.castShadow = true;
        playerGroup.add(bodyMesh);

        // Glowing Neon Visor (Faces Forward: -Z)
        const visorMat = new THREE.MeshStandardMaterial({color: 0x0ea5e9, emissive: 0x0ea5e9, emissiveIntensity: 0.8});
        const visorMesh = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.4, 0.3), visorMat);
        visorMesh.position.set(0, 0.5, -0.45); 
        playerGroup.add(visorMesh);

        // Backpack (Faces Backward: +Z)
        const packMat = new THREE.MeshStandardMaterial({color: 0x1e293b, roughness: 0.8});
        const packMesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), packMat);
        packMesh.position.set(0, 0.2, 0.45);
        playerGroup.add(packMesh);

        scene.add(playerGroup);

        // --- 5. INPUT HANDLING ---
        const keys = { w: false, a: false, s: false, d: false, space: false, up: false, down: false, left: false, right: false };
        
        window.addEventListener('keydown', (e) => {
            if (player.isDead) return;
            const k = e.key.toLowerCase();
            if (k === 'w') keys.w = true; if (k === 'a') keys.a = true;
            if (k === 's') keys.s = true; if (k === 'd') keys.d = true;
            
            if (k === ' ') { keys.space = true; e.preventDefault(); }
            if (e.key === 'ArrowUp') { keys.up = true; e.preventDefault(); }
            if (e.key === 'ArrowDown') { keys.down = true; e.preventDefault(); }
            if (e.key === 'ArrowLeft') { keys.left = true; e.preventDefault(); }
            if (e.key === 'ArrowRight') { keys.right = true; e.preventDefault(); }
        });

        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'w') keys.w = false; if (k === 'a') keys.a = false;
            if (k === 's') keys.s = false; if (k === 'd') keys.d = false;
            if (k === ' ') keys.space = false;
            if (e.key === 'ArrowUp') keys.up = false;
            if (e.key === 'ArrowDown') keys.down = false;
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
        });

        // --- AABB COLLISION SYSTEM ---
        function checkCollision(x, y, z) {
            // Player Bounding Box (Slightly narrower than 0.5 to prevent edge snagging)
            let pxMin = x - 0.4, pxMax = x + 0.4; 
            let pyMin = y - 1.0, pyMax = y + 1.0;
            let pzMin = z - 0.4, pzMax = z + 0.4;

            for (let p of platforms) {
                // Platform Bounding Box
                let platMinX = p.x - p.w/2, platMaxX = p.x + p.w/2;
                let platMinY = p.y - 0.5,   platMaxY = p.y + 0.5;
                let platMinZ = p.z - p.d/2, platMaxZ = p.z + p.d/2;

                // Check for overlap on all 3 axes
                if (pxMin < platMaxX && pxMax > platMinX &&
                    pyMin < platMaxY && pyMax > platMinY &&
                    pzMin < platMaxZ && pzMax > platMinZ) {
                    return p; // Hit detected
                }
            }
            return null; // No hit
        }

        // --- 6. MAIN GAME LOOP ---
        const clock = new THREE.Clock();
        let bestAltitude = 0;

        function update() {
            if (player.isDead) return;
            const dt = Math.min(clock.getDelta(), 0.1);

            // -- Camera Orbit (Arrows) --
            if (keys.left) player.camYaw += 2 * dt;
            if (keys.right) player.camYaw -= 2 * dt;
            if (keys.up) player.pitch -= 1.5 * dt;
            if (keys.down) player.pitch += 1.5 * dt;
            player.pitch = Math.max(0.1, Math.min(Math.PI / 2.2, player.pitch));

            // -- Player Rotation (A / D) --
            let turnSpeed = 3.5 * dt;
            if (keys.a) player.facing += turnSpeed;
            if (keys.d) player.facing -= turnSpeed;
            playerGroup.rotation.y = player.facing; // Apply visual rotation

            // -- Player Forward/Back Movement (W / S) --
            let speed = 10;
            let moveZ = 0;
            if (keys.w) moveZ = 1;  // Forward
            if (keys.s) moveZ = -1; // Backward

            if (moveZ !== 0) {
                // -Z is forward in Three.js, so we push along the facing angle
                player.vx = Math.sin(player.facing) * -moveZ * speed;
                player.vz = Math.cos(player.facing) * -moveZ * speed;
            } else {
                player.vx *= 0.8; // Friction
                player.vz *= 0.8;
            }

            // -- Independent Axis Collision Resolution --
            
            // X-Axis
            player.x += player.vx * dt;
            if (checkCollision(player.x, player.y, player.z)) {
                player.x -= player.vx * dt; // Undo move if hit wall
                player.vx = 0;
            }

            // Z-Axis
            player.z += player.vz * dt;
            if (checkCollision(player.x, player.y, player.z)) {
                player.z -= player.vz * dt; // Undo move if hit wall
                player.vz = 0;
            }

            // Y-Axis (Gravity & Jumping)
            player.vy -= 30 * dt; 
            player.y += player.vy * dt;
            player.onGround = false;

            let hitP = checkCollision(player.x, player.y, player.z);
            if (hitP) {
                if (player.vy < 0) { 
                    // Landed on top
                    player.y = hitP.y + 0.5 + 1.0; 
                    player.vy = 0;
                    player.onGround = true;
                } else if (player.vy > 0) { 
                    // Hit head on bottom
                    player.y = hitP.y - 0.5 - 1.0;
                    player.vy = 0;
                }
            }

            if (player.onGround && keys.space) {
                player.vy = 16;
                player.onGround = false;
            }

            // Apply final validated positions to mesh
            playerGroup.position.set(player.x, player.y, player.z);

            // -- Environment & Camera --
            let heightFactor = Math.max(0, Math.min(player.y / 200, 1));
            let skyColor = new THREE.Color().lerpColors(new THREE.Color(0x87CEEB), new THREE.Color(0x0f0524), heightFactor);
            scene.background = skyColor;
            scene.fog.color = skyColor;

            let camDist = 8;
            let cx = player.x + camDist * Math.sin(player.camYaw) * Math.cos(player.pitch);
            let cy = player.y + 1 + camDist * Math.sin(player.pitch);
            let cz = player.z + camDist * Math.cos(player.camYaw) * Math.cos(player.pitch);
            
            camera.position.set(cx, cy, cz);
            camera.lookAt(player.x, player.y + 1, player.z);

            // -- Infinite Generation --
            if (highestPlatformY - player.y < 30) {
                let lastP = platforms[platforms.length - 1];
                let nx = lastP.x + (Math.random() - 0.5) * 12;
                let ny = lastP.y + Math.random() * 2.5 + 1;
                let nz = lastP.z + (Math.random() - 0.5) * 12;
                let size = Math.random() * 4 + 3;
                createPlatform(nx, ny, nz, size, size);
            }

            // Memory Cleanup
            for (let i = platforms.length - 1; i >= 0; i--) {
                if (platforms[i].y < player.y - 40) {
                    scene.remove(platforms[i].mesh);
                    platforms.splice(i, 1);
                }
            }

            // UI
            let currentAlt = Math.max(0, Math.floor(player.y));
            if (currentAlt > player.maxAltitude) player.maxAltitude = currentAlt;
            document.getElementById('altitude').innerText = currentAlt + "m";
            
            // Death
            if (player.y < player.maxAltitude - 15 || player.y < -5) {
                player.isDead = true;
                if (player.maxAltitude > bestAltitude) bestAltitude = player.maxAltitude;
                document.getElementById('death-score').innerText = `Final Altitude: ${player.maxAltitude}m`;
                document.getElementById('high-score').innerText = `Best: ${bestAltitude}m`;
                document.getElementById('death-screen').style.display = 'flex';
            }

            renderer.render(scene, camera);
        }

        function restartGame() {
            document.getElementById('death-screen').style.display = 'none';
            player.isDead = false;
            player.x = 0; player.y = 5; player.z = 0;
            player.vx = 0; player.vy = 0; player.vz = 0;
            player.facing = 0; player.camYaw = 0; player.pitch = 0.3;
            player.maxAltitude = 0;
            generateInitialWorld();
        }

        generateInitialWorld();
        renderer.setAnimationLoop(update);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
