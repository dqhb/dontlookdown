<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dontlookdown</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, sans-serif; user-select: none; }
        canvas { display: block; }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        #top-hud { padding: 20px 40px; display: flex; justify-content: space-between; background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent); }
        .hud-text { font-size: 2rem; font-weight: bold; color: white; text-shadow: 0 4px 6px rgba(0,0,0,0.5); }
        #altitude { color: #38bdf8; }
        #high-score { color: #fbbf24; font-size: 1.2rem; margin-top: 5px; }

        #controls { text-align: center; color: rgba(255,255,255,0.8); padding-bottom: 20px; font-size: 1.1rem; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        .key { display: inline-block; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; border: 1px solid #555; margin: 0 2px; }

        #death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.9); display: none; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto; z-index: 10;
        }
        #death-screen h1 { font-size: 5rem; color: #ef4444; margin-bottom: 0; text-transform: uppercase; letter-spacing: 5px; }
        #death-score { font-size: 2rem; color: white; margin: 20px 0 40px 0; }
        button { background: #38bdf8; color: #0f172a; border: none; padding: 15px 40px; font-size: 1.5rem; font-weight: bold; border-radius: 8px; cursor: pointer; text-transform: uppercase; transition: 0.2s; }
        button:hover { transform: scale(1.05); background: #7dd3fc; box-shadow: 0 0 20px #38bdf8; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="top-hud">
            <div>
                <div class="hud-text" id="altitude">0m</div>
                <div id="high-score">Best: 0m</div>
            </div>
        </div>
        
        <div id="controls">
            Move: <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> &nbsp;|&nbsp; 
            Camera: <span class="key">Arrows</span> &nbsp;|&nbsp; 
            Jump: <span class="key">Space</span>
        </div>
    </div>

    <div id="death-screen">
        <h1>YOU FELL</h1>
        <div id="death-score">Final Altitude: 0m</div>
        <button onclick="restartGame()">Try Again</button>
    </div>

    <script>
        // --- 1. SETUP THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 2. GENERATE PROCEDURAL TEXTURES ---
        function createCheckerboard() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Base color
            context.fillStyle = '#1e293b'; 
            context.fillRect(0, 0, 256, 256);
            
            // Checker pattern
            context.fillStyle = '#334155';
            context.fillRect(0, 0, 128, 128);
            context.fillRect(128, 128, 128, 128);
            
            // Outer glowing border for readability
            context.strokeStyle = '#38bdf8';
            context.lineWidth = 4;
            context.strokeRect(2, 2, 252, 252);

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter; // Sharp pixels
            return tex;
        }

        const platformMaterial = new THREE.MeshStandardMaterial({ 
            map: createCheckerboard(), 
            roughness: 0.7, metalness: 0.2 
        });

        // --- 3. PLATFORM GENERATOR ---
        let platforms = [];
        let highestPlatformY = 0;
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);

        function createPlatform(x, y, z, width, depth) {
            const mesh = new THREE.Mesh(boxGeo, platformMaterial);
            mesh.scale.set(width, 1, depth);
            mesh.position.set(x, y, z);
            mesh.castShadow = true; mesh.receiveShadow = true;
            
            // Fix texture tiling based on scale
            const clonedMat = platformMaterial.clone();
            clonedMat.map = platformMaterial.map.clone();
            clonedMat.map.repeat.set(width / 4, depth / 4);
            clonedMat.map.wrapS = THREE.RepeatWrapping;
            clonedMat.map.wrapT = THREE.RepeatWrapping;
            mesh.material = clonedMat;

            scene.add(mesh);
            platforms.push({ mesh, x, y, z, w: width, d: depth });
            if (y > highestPlatformY) highestPlatformY = y;
        }

        function generateInitialWorld() {
            platforms.forEach(p => scene.remove(p.mesh));
            platforms = [];
            highestPlatformY = 0;

            // Ground Zero
            createPlatform(0, -1, 0, 15, 15);

            // Generate first batch
            let px = 0; let py = 2; let pz = 0;
            for(let i=0; i<20; i++) {
                // Jump math (max jump is roughly 4 units high, 8 units across)
                px += (Math.random() - 0.5) * 12;
                py += Math.random() * 2 + 1; // Always goes up
                pz += (Math.random() - 0.5) * 12;
                
                let size = Math.random() * 4 + 3; // Width 3 to 7
                createPlatform(px, py, pz, size, size);
            }
        }

        // --- 4. PLAYER & PHYSICS ---
        const player = {
            x: 0, y: 5, z: 0, 
            vx: 0, vy: 0, vz: 0,
            yaw: 0, pitch: 0.3, 
            onGround: false, isDead: false, maxAltitude: 0
        };

        const pMesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1, 4, 8), new THREE.MeshStandardMaterial({color: 0xfbbf24, roughness: 0.2, metalness: 0.8}));
        pMesh.castShadow = true;
        scene.add(pMesh);

        // --- 5. INPUT HANDLING ---
        const keys = { w: false, a: false, s: false, d: false, space: false, up: false, down: false, left: false, right: false };
        
        window.addEventListener('keydown', (e) => {
            if (player.isDead) return;
            const k = e.key.toLowerCase();
            if (k === 'w') keys.w = true; if (k === 'a') keys.a = true;
            if (k === 's') keys.s = true; if (k === 'd') keys.d = true;
            
            // PreventDefault stops browser scrolling while jumping/moving camera!
            if (k === ' ') { keys.space = true; e.preventDefault(); }
            if (e.key === 'ArrowUp') { keys.up = true; e.preventDefault(); }
            if (e.key === 'ArrowDown') { keys.down = true; e.preventDefault(); }
            if (e.key === 'ArrowLeft') { keys.left = true; e.preventDefault(); }
            if (e.key === 'ArrowRight') { keys.right = true; e.preventDefault(); }
        });

        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'w') keys.w = false; if (k === 'a') keys.a = false;
            if (k === 's') keys.s = false; if (k === 'd') keys.d = false;
            if (k === ' ') keys.space = false;
            if (e.key === 'ArrowUp') keys.up = false;
            if (e.key === 'ArrowDown') keys.down = false;
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
        });

        // --- 6. MAIN GAME LOOP ---
        const clock = new THREE.Clock();
        let bestAltitude = 0;

        function update() {
            if (player.isDead) return;
            const dt = Math.min(clock.getDelta(), 0.1);

            // -- Camera Orientation --
            if (keys.left) player.yaw += 2 * dt;
            if (keys.right) player.yaw -= 2 * dt;
            if (keys.up) player.pitch -= 1.5 * dt;
            if (keys.down) player.pitch += 1.5 * dt;
            player.pitch = Math.max(0.1, Math.min(Math.PI / 2.2, player.pitch));

            // -- WASD Movement (Relative to Camera) --
            let speed = 12; // Base movement speed
            let moveX = 0; let moveZ = 0;
            
            if (keys.w) moveZ -= 1;
            if (keys.s) moveZ += 1;
            if (keys.a) moveX -= 1;
            if (keys.d) moveX += 1;

            if (moveX !== 0 || moveZ !== 0) {
                let length = Math.sqrt(moveX*moveX + moveZ*moveZ);
                moveX /= length; moveZ /= length;
                
                let c = Math.cos(player.yaw); let s = Math.sin(player.yaw);
                let worldX = moveX * c - moveZ * s;
                let worldZ = moveX * s + moveZ * c;

                // Apply velocity with some momentum
                player.vx = worldX * speed;
                player.vz = worldZ * speed;
            } else {
                // Friction when keys released
                player.vx *= 0.8; 
                player.vz *= 0.8;
            }

            // -- Physics & Collision --
            player.vy -= 30 * dt; // Gravity
            let nextY = player.y + player.vy * dt;
            let landed = false;

            // Check platform collisions (only when falling)
            if (player.vy < 0) {
                for (let p of platforms) {
                    // Check if player's feet (y - 1) cross the top of the platform (p.y + 0.5)
                    let pTop = p.y + 0.5;
                    let pLeft = p.x - p.w/2 - 0.5; let pRight = p.x + p.w/2 + 0.5;
                    let pBack = p.z - p.d/2 - 0.5; let pFront = p.z + p.d/2 + 0.5;

                    if (player.y - 1 >= pTop - 0.2 && nextY - 1 <= pTop) {
                        if (player.x > pLeft && player.x < pRight && player.z > pBack && player.z < pFront) {
                            nextY = pTop + 1; // Snap to top
                            player.vy = 0;
                            landed = true;
                            break;
                        }
                    }
                }
            }

            player.onGround = landed;
            if (player.onGround && keys.space) {
                player.vy = 16; // Jump Power
                player.onGround = false;
            }

            player.x += player.vx * dt;
            player.y = nextY;
            player.z += player.vz * dt;
            pMesh.position.set(player.x, player.y, player.z);

            // -- Dynamic Sky & Fog Colors --
            // As you go higher, sky turns from blue to dark space purple
            let heightFactor = Math.min(player.y / 200, 1);
            let skyColor = new THREE.Color().lerpColors(new THREE.Color(0x87CEEB), new THREE.Color(0x0f0524), heightFactor);
            scene.background = skyColor;
            scene.fog.color = skyColor;

            // -- Camera Positioning --
            let camDist = 8;
            let cx = player.x + camDist * Math.sin(player.yaw) * Math.cos(player.pitch);
            let cy = player.y + 1 + camDist * Math.sin(player.pitch);
            let cz = player.z + camDist * Math.cos(player.yaw) * Math.cos(player.pitch);
            
            camera.position.set(cx, cy, cz);
            camera.lookAt(player.x, player.y + 1, player.z);

            // -- Infinite Generation & Cleanup --
            // Generate new platforms ahead
            if (highestPlatformY - player.y < 30) {
                let lastP = platforms[platforms.length - 1];
                let nx = lastP.x + (Math.random() - 0.5) * 12;
                let ny = lastP.y + Math.random() * 2.5 + 1;
                let nz = lastP.z + (Math.random() - 0.5) * 12;
                let size = Math.random() * 4 + 3;
                createPlatform(nx, ny, nz, size, size);
            }

            // Remove platforms too far below to save memory
            for (let i = platforms.length - 1; i >= 0; i--) {
                if (platforms[i].y < player.y - 40) {
                    scene.remove(platforms[i].mesh);
                    platforms.splice(i, 1);
                }
            }

            // -- UI Updates --
            let currentAlt = Math.max(0, Math.floor(player.y));
            if (currentAlt > player.maxAltitude) player.maxAltitude = currentAlt;
            document.getElementById('altitude').innerText = currentAlt + "m";
            
            // -- Death Condition --
            // If you fall 15 meters below your highest achieved altitude
            if (player.y < player.maxAltitude - 15 || player.y < -5) {
                player.isDead = true;
                if (player.maxAltitude > bestAltitude) bestAltitude = player.maxAltitude;
                document.getElementById('death-score').innerText = `Final Altitude: ${player.maxAltitude}m`;
                document.getElementById('high-score').innerText = `Best: ${bestAltitude}m`;
                document.getElementById('death-screen').style.display = 'flex';
            }

            renderer.render(scene, camera);
        }

        function restartGame() {
            document.getElementById('death-screen').style.display = 'none';
            player.isDead = false;
            player.x = 0; player.y = 5; player.z = 0;
            player.vx = 0; player.vy = 0; player.vz = 0;
            player.maxAltitude = 0;
            generateInitialWorld();
        }

        generateInitialWorld();
        renderer.setAnimationLoop(update);

        // Handle Resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
